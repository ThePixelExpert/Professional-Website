---
phase: 02-schema-backend-refactor
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - contact-backend/database.js
  - contact-backend/src/services/database.js
autonomous: true

must_haves:
  truths:
    - "Backend uses Supabase client for all database operations"
    - "All existing API endpoints continue to work"
    - "Order CRUD operations work via Supabase"
    - "Customer upsert operations work via Supabase with address fallback logic preserved"
    - "Admin user authentication queries work via Supabase"
    - "Health check verifies Supabase connectivity"
    - "Both updatePaymentStatus and updateOrderPaymentStatus methods work correctly"
  artifacts:
    - path: "contact-backend/src/services/database.js"
      provides: "Supabase-based database service module"
      contains: "supabaseAdmin"
    - path: "contact-backend/database.js"
      provides: "Compatibility wrapper pointing to new service"
      contains: "require('./src/services/database')"
  key_links:
    - from: "contact-backend/src/services/database.js"
      to: "contact-backend/src/config/supabase.js"
      via: "imports supabaseAdmin client"
      pattern: "require.*config/supabase"
    - from: "contact-backend/server.js"
      to: "contact-backend/database.js"
      via: "existing require"
      pattern: "require.*database"
    - from: "contact-backend/src/services/database.js:createOrUpdateCustomer"
      to: "customers table"
      via: "upsert with address fallback logic"
      pattern: "address.*shippingAddress"
---

<objective>
Refactor the database module to use Supabase client instead of raw pg Pool

Purpose: Replace direct PostgreSQL queries with Supabase query builder calls while preserving the existing API contract so server.js requires no changes.

Output: New database service module using Supabase, compatibility wrapper maintaining existing exports
</objective>

<execution_context>
@/home/logan/.claude/get-shit-done/workflows/execute-plan.md
@/home/logan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-schema-backend-refactor/02-RESEARCH.md
@.planning/phases/02-schema-backend-refactor/02-01-SUMMARY.md
@contact-backend/database.js
@contact-backend/src/config/supabase.js
@contact-backend/server.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Supabase database service module</name>
  <files>contact-backend/src/services/database.js</files>
  <action>
Create a new database service module that implements the same interface as the current database.js but uses Supabase:

1. Create `contact-backend/src/services/database.js`

2. Import supabaseAdmin from config:
   ```javascript
   const { supabaseAdmin, hasAdminClient } = require('../config/supabase')
   ```

3. Implement ALL methods from current database.js using Supabase query builder:

   **testConnection():**
   ```javascript
   async testConnection() {
     const { data, error } = await supabaseAdmin.from('orders').select('count').limit(1)
     if (error) throw error
     return true
   }
   ```

   **createOrder(orderData):**
   - Use `.from('orders').insert({...}).select().single()`
   - Map camelCase params to snake_case columns
   - Return the created row

   **getOrders(limit, offset):**
   - Use `.from('orders').select('*').order('created_at', { ascending: false }).limit(limit).range(offset, offset + limit - 1)`

   **getOrder(id):**
   - Use `.from('orders').select('*').eq('id', id).single()`

   **getOrderByIdAndEmail(id, email):**
   - Use `.from('orders').select('*').eq('id', id).eq('customer_email', email.toLowerCase()).single()`

   **updateOrderStatus(id, status, trackingNumber):**
   - Use `.from('orders').update({status, tracking_number: trackingNumber}).eq('id', id).select().single()`
   - Note: Do NOT manually set updated_at - trigger handles it

   **updatePaymentStatus(id, paymentStatus, paymentIntentId):**
   - IMPORTANT: Parameters are (id, paymentStatus, paymentIntentId) - id is FIRST
   - Use `.from('orders').update({ payment_status: paymentStatus, payment_intent_id: paymentIntentId }).eq('id', id).select().single()`

   **updateOrderPaymentStatus(orderId, paymentStatus, paymentIntentId):**
   - IMPORTANT: This is a SEPARATE method from updatePaymentStatus
   - Parameters are (orderId, paymentStatus, paymentIntentId) but the original SQL uses $1=paymentStatus, $2=paymentIntentId, $3=orderId
   - Implementation is same as updatePaymentStatus - just an alias with same parameter order
   - Use `.from('orders').update({ payment_status: paymentStatus, payment_intent_id: paymentIntentId }).eq('id', orderId).select().single()`

   **createOrUpdateCustomer(customerData):**
   - CRITICAL: Must preserve the address fallback logic from original database.js
   - Extract: `{ name, email, phone, address, shippingAddress, billingAddress } = customerData`
   - Build the data object with fallback logic:
     ```javascript
     const data = {
       name,
       email,
       phone,
       address: address || shippingAddress,           // Legacy support
       shipping_address: shippingAddress || address,  // Fallback to address
       billing_address: billingAddress || shippingAddress || address  // Cascade fallback
     }
     ```
   - Use `.from('customers').upsert(data, { onConflict: 'email' }).select().single()`

   **getProducts() / getProduct(id):**
   - Standard select queries

   **getAdminUser(username):**
   - Use `.from('admin_users').select('*').eq('username', username).single()`

   **createAdminUser(username, passwordHash, email):**
   - Use insert with select returning specific columns

   **updateAdminLastLogin(username):**
   - Use `.from('admin_users').update({ last_login: new Date().toISOString() }).eq('username', username)`

   **close():**
   - No-op for Supabase (connection pooling handled automatically)

4. Error handling: Always check `error` from Supabase responses:
   ```javascript
   if (error) {
     console.error('Database error:', error)
     throw error
   }
   ```

5. Export same interface:
   ```javascript
   module.exports = { db, initializeDatabase }
   ```

6. For `initializeDatabase()`: Make it a no-op that logs "Database schema managed via Supabase migrations" - migrations handle schema now.

Critical: Use supabaseAdmin (service role) for ALL operations since backend needs full access. The public client respecting RLS is for future frontend use.
  </action>
  <verify>
Run the smoke test to verify client connectivity: `cd contact-backend && npm run test:supabase`. Should show successful connection.
  </verify>
  <done>
New database service module created with all methods reimplemented using Supabase query builder, including BOTH updatePaymentStatus and updateOrderPaymentStatus methods, and createOrUpdateCustomer with address fallback logic.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update database.js wrapper</name>
  <files>contact-backend/database.js</files>
  <action>
Convert the original database.js to a compatibility wrapper:

1. **Replace contact-backend/database.js content** with a simple re-export:
   ```javascript
   // Database module - now uses Supabase
   // This file maintains backward compatibility for existing imports
   // Actual implementation is in src/services/database.js

   const { db, initializeDatabase } = require('./src/services/database')

   module.exports = { db, initializeDatabase }
   ```

2. Verify the wrapper imports correctly by running:
   ```bash
   cd contact-backend && node -e "const db = require('./database'); console.log('Wrapper loads:', Object.keys(db))"
   ```
   Expected output: `Wrapper loads: [ 'db', 'initializeDatabase' ]`
  </action>
  <verify>
Run: `cd contact-backend && node -e "const { db } = require('./database'); console.log('Methods:', Object.keys(db))"`
Should output all method names including createOrder, getOrders, updatePaymentStatus, updateOrderPaymentStatus, createOrUpdateCustomer, etc.
  </verify>
  <done>
database.js is now a thin wrapper re-exporting from src/services/database.js.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integration testing</name>
  <files></files>
  <action>
Start services and verify backend works end-to-end:

1. **Start local Supabase** (if not running):
   ```bash
   npx supabase start
   ```

2. **Start the backend server**:
   ```bash
   cd contact-backend
   npm start
   ```

3. **Test each database operation via API**:

   a. Health check:
   ```bash
   curl http://localhost:3001/api/health
   ```
   Expected: `{"status":"ok","database":"connected",...}`

   b. Create an order:
   ```bash
   curl -X POST http://localhost:3001/api/orders \
     -H "Content-Type: application/json" \
     -d '{"buyerEmail":"test@test.com","buyerName":"Test User","items":[{"name":"Test Item","price":50}],"shippingAddress":"123 Test St"}'
   ```
   Expected: 200 with order object including UUID id

   c. Track the order (use the returned order id):
   ```bash
   curl -X POST http://localhost:3001/api/orders/track \
     -H "Content-Type: application/json" \
     -d '{"email":"test@test.com","orderId":"<order-id-from-previous>"}'
   ```
   Expected: 200 with order details

4. **Verify in Supabase Studio** (http://localhost:54323):
   - Orders table should have the test order
   - Customers table should have test@test.com customer
   - Customer should have address fields populated based on fallback logic

5. If any endpoint fails, check error logs and fix the corresponding method in src/services/database.js.

Note: Admin endpoints require JWT token - skip testing those here, they'll be tested in Phase 3.
  </action>
  <verify>
1. `curl http://localhost:3001/api/health` returns status ok with database connected
2. Order creation succeeds and returns valid order object
3. Order tracking returns the created order
4. Supabase Studio shows records in orders and customers tables
5. Customer record has address fields populated (including fallback values)
  </verify>
  <done>
Backend fully operational with Supabase, all public API endpoints working, database operations verified in Supabase Studio.
  </done>
</task>

</tasks>

<verification>
1. Health endpoint reports database connected
2. Order creation works end-to-end
3. Customer upsert works with address fallback logic (visible in Supabase Studio)
4. Order tracking returns correct data
5. No pg Pool references remain in active code paths
6. Server starts without errors
7. Both updatePaymentStatus and updateOrderPaymentStatus methods exist and work
</verification>

<success_criteria>
- [ ] src/services/database.js exists with Supabase implementation
- [ ] database.js re-exports from new location
- [ ] Backend server starts without errors
- [ ] Health check shows database connected
- [ ] Order creation creates records in Supabase
- [ ] Order tracking retrieves records from Supabase
- [ ] Customer records appear in customers table with correct address fallback
- [ ] Both updatePaymentStatus(id, ...) and updateOrderPaymentStatus(orderId, ...) implemented
- [ ] All existing functionality preserved
</success_criteria>

<output>
After completion, create `.planning/phases/02-schema-backend-refactor/02-02-SUMMARY.md`
</output>
