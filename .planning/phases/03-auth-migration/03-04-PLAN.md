---
phase: 03-auth-migration
plan: 04
type: execute
wave: 2
depends_on: ["03-02"]
files_modified:
  - src/lib/supabase.js
  - src/contexts/AuthContext.js
  - src/components/ProtectedRoute.js
  - src/components/AdminRoute.js
  - package.json
autonomous: true

must_haves:
  truths:
    - "React app has Supabase client configured for browser"
    - "AuthContext provides user state to entire app"
    - "ProtectedRoute redirects unauthenticated users"
    - "AdminRoute redirects non-admin users"
  artifacts:
    - path: "src/lib/supabase.js"
      provides: "Browser Supabase client"
      exports: ["supabase"]
    - path: "src/contexts/AuthContext.js"
      provides: "React auth state context"
      exports: ["AuthProvider", "useAuth"]
    - path: "src/components/ProtectedRoute.js"
      provides: "Generic auth route guard"
      exports: ["ProtectedRoute"]
    - path: "src/components/AdminRoute.js"
      provides: "Admin-specific route guard"
      exports: ["AdminRoute"]
  key_links:
    - from: "src/contexts/AuthContext.js"
      to: "src/lib/supabase.js"
      via: "imports supabase client"
      pattern: "import.*supabase.*from.*lib/supabase"
    - from: "src/components/AdminRoute.js"
      to: "src/contexts/AuthContext.js"
      via: "uses useAuth hook"
      pattern: "useAuth"
---

<objective>
Create React authentication foundation with Supabase client, AuthContext, and route guards

Purpose: Establish frontend auth infrastructure that provides global auth state, handles session persistence, and protects routes from unauthorized access.

Output: Browser Supabase client, AuthProvider context, ProtectedRoute and AdminRoute components.
</objective>

<execution_context>
@/home/logan/.claude/get-shit-done/workflows/execute-plan.md
@/home/logan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-auth-migration/03-CONTEXT.md
@.planning/phases/03-auth-migration/03-RESEARCH.md
@src/index.js
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create browser Supabase client</name>
  <files>
    package.json
    src/lib/supabase.js
  </files>
  <action>
1. Check if @supabase/supabase-js is in frontend package.json. If not, install it:
   ```bash
   npm install @supabase/supabase-js
   ```

2. Create `src/lib/` directory if it doesn't exist

3. Create `src/lib/supabase.js`:
   ```javascript
   import { createClient } from '@supabase/supabase-js';

   const supabaseUrl = process.env.REACT_APP_SUPABASE_URL;
   const supabaseAnonKey = process.env.REACT_APP_SUPABASE_ANON_KEY;

   if (!supabaseUrl || !supabaseAnonKey) {
     throw new Error(
       'Missing Supabase environment variables. ' +
       'Ensure REACT_APP_SUPABASE_URL and REACT_APP_SUPABASE_ANON_KEY are set.'
     );
   }

   export const supabase = createClient(supabaseUrl, supabaseAnonKey);
   ```

4. Update `.env.template` (if exists) or create `.env` guidance for frontend:
   - REACT_APP_SUPABASE_URL (same as backend SUPABASE_URL)
   - REACT_APP_SUPABASE_ANON_KEY (same as backend SUPABASE_ANON_KEY)

Note: React env vars must be prefixed with REACT_APP_ to be included in the build.
  </action>
  <verify>
    - `src/lib/supabase.js` exists and exports supabase client
    - @supabase/supabase-js is in package.json dependencies
  </verify>
  <done>
    - Browser Supabase client configured with env vars
    - Uses REACT_APP_ prefix for Create React App compatibility
    - Module exports supabase client instance
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AuthContext with session management</name>
  <files>
    src/contexts/AuthContext.js
  </files>
  <action>
1. Create `src/contexts/` directory if it doesn't exist

2. Create `src/contexts/AuthContext.js`:
   ```javascript
   import { createContext, useContext, useEffect, useState } from 'react';
   import { supabase } from '../lib/supabase';

   const AuthContext = createContext({});

   export function AuthProvider({ children }) {
     const [user, setUser] = useState(null);
     const [loading, setLoading] = useState(true);

     useEffect(() => {
       // Check active session on mount
       // CRITICAL: Call getSession() first, THEN listen for changes
       supabase.auth.getSession().then(({ data: { session } }) => {
         setUser(session?.user ?? null);
         setLoading(false);
       });

       // Listen for auth changes (login, logout, token refresh)
       const { data: { subscription } } = supabase.auth.onAuthStateChange(
         (_event, session) => {
           setUser(session?.user ?? null);
           // Don't set loading false here - only on initial load
         }
       );

       // Cleanup subscription on unmount
       return () => subscription.unsubscribe();
     }, []);

     // Helper to check if user has admin role
     const isAdmin = () => {
       return user?.app_metadata?.user_role === 'admin';
     };

     // Sign out function (global - all devices)
     const signOut = async () => {
       const { error } = await supabase.auth.signOut({ scope: 'global' });
       if (error) {
         console.error('Sign out error:', error);
         throw error;
       }
     };

     const value = {
       user,
       loading,
       isAdmin,
       signOut,
       supabase  // Expose client for direct auth operations
     };

     return (
       <AuthContext.Provider value={value}>
         {children}
       </AuthContext.Provider>
     );
   }

   export const useAuth = () => {
     const context = useContext(AuthContext);
     if (!context) {
       throw new Error('useAuth must be used within an AuthProvider');
     }
     return context;
   };
   ```

Note: The loading state prevents flash of unauthenticated content on page load. The isAdmin() helper reads from app_metadata where Auth Hook puts the role.
  </action>
  <verify>
    - `src/contexts/AuthContext.js` exists
    - Exports AuthProvider and useAuth
    - Calls getSession() on mount before onAuthStateChange
    - Provides user, loading, isAdmin, signOut
  </verify>
  <done>
    - AuthContext provides global auth state
    - Loading state prevents auth check race conditions
    - isAdmin() helper checks app_metadata.user_role
    - signOut() performs global session revocation
  </done>
</task>

<task type="auto">
  <name>Task 3: Create ProtectedRoute and AdminRoute components</name>
  <files>
    src/components/ProtectedRoute.js
    src/components/AdminRoute.js
  </files>
  <action>
1. Create `src/components/ProtectedRoute.js`:
   ```javascript
   import { useAuth } from '../contexts/AuthContext';

   /**
    * Generic protected route - requires any authenticated user
    * Redirects to home if not authenticated
    */
   function ProtectedRoute({ children, redirectTo = '/' }) {
     const { user, loading } = useAuth();

     if (loading) {
       return (
         <div style={{
           display: 'flex',
           justifyContent: 'center',
           alignItems: 'center',
           height: '100vh'
         }}>
           <div>Loading...</div>
         </div>
       );
     }

     if (!user) {
       // Using hash-based navigation
       window.location.hash = redirectTo;
       return null;
     }

     return children;
   }

   export default ProtectedRoute;
   ```

2. Create `src/components/AdminRoute.js`:
   ```javascript
   import { useAuth } from '../contexts/AuthContext';

   /**
    * Admin-only route guard
    * Redirects to admin login if not authenticated
    * Redirects to home if authenticated but not admin
    */
   function AdminRoute({ children }) {
     const { user, loading, isAdmin } = useAuth();

     if (loading) {
       return (
         <div style={{
           display: 'flex',
           justifyContent: 'center',
           alignItems: 'center',
           height: '100vh'
         }}>
           <div>Loading...</div>
         </div>
       );
     }

     if (!user) {
       // Store intended destination for post-login redirect
       sessionStorage.setItem('auth_redirect', window.location.hash);
       window.location.hash = '#/admin/login';
       return null;
     }

     if (!isAdmin()) {
       // User is logged in but not an admin
       // Redirect to home with a message (or could show access denied)
       console.warn('Access denied: Admin role required');
       window.location.hash = '#/';
       return null;
     }

     return children;
   }

   export default AdminRoute;
   ```

Note: Using window.location.hash for navigation since the app uses HashRouter pattern. sessionStorage stores redirect destination for OAuth callback handling.
  </action>
  <verify>
    - `src/components/ProtectedRoute.js` exists and exports component
    - `src/components/AdminRoute.js` exists and exports component
    - Both show loading spinner while auth state is being determined
    - Both redirect appropriately when auth checks fail
  </verify>
  <done>
    - ProtectedRoute requires any authenticated user
    - AdminRoute requires authenticated user with admin role
    - Both handle loading state with spinner
    - Both use hash-based navigation compatible with existing routing
    - AdminRoute stores redirect destination in sessionStorage
  </done>
</task>

</tasks>

<verification>
1. Verify all files exist:
   ```bash
   ls -la src/lib/supabase.js src/contexts/AuthContext.js src/components/ProtectedRoute.js src/components/AdminRoute.js
   ```

2. Verify exports are correct:
   ```bash
   grep -E "export (const|default|function)" src/lib/supabase.js src/contexts/AuthContext.js src/components/ProtectedRoute.js src/components/AdminRoute.js
   ```

3. Verify @supabase/supabase-js is installed:
   ```bash
   grep "@supabase/supabase-js" package.json
   ```
</verification>

<success_criteria>
- supabase.js exports configured browser client
- AuthContext exports AuthProvider and useAuth
- AuthProvider manages user state, loading, isAdmin, signOut
- ProtectedRoute redirects unauthenticated users
- AdminRoute redirects non-admin users
- All components handle loading state properly
</success_criteria>

<output>
After completion, create `.planning/phases/03-auth-migration/03-04-SUMMARY.md`
</output>
