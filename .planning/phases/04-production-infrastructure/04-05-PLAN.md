---
phase: 04-production-infrastructure
plan: 05
type: execute
wave: 3
depends_on: ["04-03"]
files_modified:
  - production/docker-compose.backup.yml
  - production/backup.sh
  - docs/BACKUP_RESTORE.md
autonomous: true

must_haves:
  truths:
    - "Database is backed up daily at 2 AM"
    - "Backups are retained for 7 days"
    - "Restore procedure is documented and tested"
  artifacts:
    - path: "production/docker-compose.backup.yml"
      provides: "Automated PostgreSQL backup service"
      contains: "kartoza/pg-backup"
    - path: "production/backup.sh"
      provides: "Manual backup and restore commands"
      contains: "pg_dump"
    - path: "docs/BACKUP_RESTORE.md"
      provides: "Backup and restore documentation"
      contains: "Restore"
  key_links:
    - from: "production/docker-compose.backup.yml"
      to: "PostgreSQL database"
      via: "POSTGRES_HOST connection"
      pattern: "POSTGRES_HOST=db"
    - from: "production/backup.sh"
      to: "Docker exec"
      via: "pg_dump via container"
      pattern: "docker exec.*pg_dump"
---

<objective>
Create backup automation for PostgreSQL database with retention and documented restore procedures.

Purpose: Automated backups protect against data loss. The kartoza/pg-backup image provides scheduled backups with retention, and manual scripts enable on-demand backup/restore.

Output: Automated backup service, manual backup script, and comprehensive backup/restore documentation
</objective>

<execution_context>
@/home/logan/.claude/get-shit-done/workflows/execute-plan.md
@/home/logan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-production-infrastructure/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create automated backup Docker Compose</name>
  <files>production/docker-compose.backup.yml</files>
  <action>
Create production/docker-compose.backup.yml for automated PostgreSQL backups.

```yaml
# Automated PostgreSQL Backup Service
# Uses kartoza/pg-backup for scheduled backups with retention
#
# Deploy: docker compose -f docker-compose.backup.yml up -d
# Backups stored in: /opt/backups/postgres/

services:
  db-backup:
    image: kartoza/pg-backup:latest
    container_name: supabase-db-backup
    restart: unless-stopped
    environment:
      # Database connection (uses Supabase's internal db container)
      - POSTGRES_HOST=db
      - POSTGRES_PORT=5432
      - POSTGRES_DB=postgres
      - POSTGRES_USER=postgres
      - POSTGRES_PASS=${POSTGRES_PASSWORD}

      # Backup schedule (cron format)
      # Default: Daily at 2 AM
      - CRON_SCHEDULE=0 2 * * *

      # Backup location inside container
      - BACKUP_DIR=/backups

      # Retention: Remove backups older than N days
      - REMOVE_BEFORE=7

      # Backup format: gzip compressed
      - ARCHIVE_FORMAT=Fc

      # Dump all databases (we only have postgres, but this is safer)
      - DUMP_ARGS=--no-owner --no-acl

    volumes:
      # Mount backup directory from host
      - /opt/backups/postgres:/backups

    networks:
      - supabase_default

    depends_on:
      - db

    # Health check - verify last backup exists
    healthcheck:
      test: ["CMD", "test", "-d", "/backups"]
      interval: 1h
      timeout: 10s
      retries: 3

networks:
  supabase_default:
    external: true

# Note: This service connects to the 'db' container in Supabase's network
# POSTGRES_PASSWORD must be set in the .env file used by Supabase
```

**Configuration notes:**
- Uses same POSTGRES_PASSWORD as Supabase stack (from .env)
- Connects to `supabase_default` network to reach the db container
- Backups stored on host at /opt/backups/postgres (survives container recreation)
- 7-day retention balances storage usage with recovery options
- `--no-owner --no-acl` makes dumps portable across installations
  </action>
  <verify>docker compose -f production/docker-compose.backup.yml config >/dev/null 2>&1 && echo "Valid Compose file"</verify>
  <done>docker-compose.backup.yml configures kartoza/pg-backup with daily schedule and 7-day retention</done>
</task>

<task type="auto">
  <name>Task 2: Create manual backup/restore script</name>
  <files>production/backup.sh</files>
  <action>
Create production/backup.sh for manual backup and restore operations.

```bash
#!/bin/bash
# Manual Backup and Restore Script for Supabase PostgreSQL
# Usage:
#   ./backup.sh backup              - Create manual backup
#   ./backup.sh restore <file>      - Restore from backup file
#   ./backup.sh list                - List available backups
#   ./backup.sh storage-backup      - Backup storage files

set -e

BACKUP_DIR="/opt/backups/postgres"
STORAGE_DIR="/opt/supabase/volumes/storage"
DB_CONTAINER="supabase-db"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Create manual database backup
cmd_backup() {
    TIMESTAMP=$(date +%Y%m%d-%H%M%S)
    BACKUP_FILE="$BACKUP_DIR/manual-backup-$TIMESTAMP.sql.gz"

    log_info "Creating backup: $BACKUP_FILE"

    # Verify db container is running
    if ! docker ps --format '{{.Names}}' | grep -q "^${DB_CONTAINER}$"; then
        log_error "Database container '$DB_CONTAINER' is not running"
        exit 1
    fi

    # Create backup
    docker exec $DB_CONTAINER pg_dump -U postgres postgres \
        --no-owner --no-acl \
        | gzip > "$BACKUP_FILE"

    # Verify backup was created
    if [ -f "$BACKUP_FILE" ]; then
        SIZE=$(ls -lh "$BACKUP_FILE" | awk '{print $5}')
        log_info "Backup complete: $BACKUP_FILE ($SIZE)"
    else
        log_error "Backup failed!"
        exit 1
    fi
}

# Restore from backup
cmd_restore() {
    BACKUP_FILE="$1"

    if [ -z "$BACKUP_FILE" ]; then
        log_error "Usage: $0 restore <backup-file>"
        exit 1
    fi

    # Handle relative paths
    if [[ ! "$BACKUP_FILE" = /* ]]; then
        BACKUP_FILE="$BACKUP_DIR/$BACKUP_FILE"
    fi

    if [ ! -f "$BACKUP_FILE" ]; then
        log_error "Backup file not found: $BACKUP_FILE"
        exit 1
    fi

    log_warn "WARNING: This will OVERWRITE the current database!"
    log_warn "Backup file: $BACKUP_FILE"
    read -p "Are you sure? Type 'yes' to continue: " confirm

    if [ "$confirm" != "yes" ]; then
        log_info "Restore cancelled"
        exit 0
    fi

    log_info "Stopping Supabase services..."
    cd /opt/supabase
    docker compose stop

    log_info "Starting only database container..."
    docker compose up -d db
    sleep 10  # Wait for db to be ready

    log_info "Restoring database..."
    if [[ "$BACKUP_FILE" == *.gz ]]; then
        gunzip -c "$BACKUP_FILE" | docker exec -i $DB_CONTAINER psql -U postgres postgres
    else
        docker exec -i $DB_CONTAINER psql -U postgres postgres < "$BACKUP_FILE"
    fi

    log_info "Starting all services..."
    docker compose up -d

    log_info "Restore complete! Verify data integrity."
}

# List available backups
cmd_list() {
    log_info "Available backups in $BACKUP_DIR:"
    echo ""

    if [ -d "$BACKUP_DIR" ]; then
        ls -lh "$BACKUP_DIR"/*.gz 2>/dev/null || echo "No backup files found"
    else
        log_warn "Backup directory does not exist: $BACKUP_DIR"
    fi
}

# Backup storage files
cmd_storage_backup() {
    TIMESTAMP=$(date +%Y%m%d-%H%M%S)
    BACKUP_FILE="$BACKUP_DIR/storage-backup-$TIMESTAMP.tar.gz"

    if [ ! -d "$STORAGE_DIR" ]; then
        log_warn "Storage directory not found: $STORAGE_DIR"
        log_info "This is normal if no files have been uploaded"
        exit 0
    fi

    log_info "Creating storage backup: $BACKUP_FILE"
    tar -czf "$BACKUP_FILE" -C /opt/supabase/volumes storage

    SIZE=$(ls -lh "$BACKUP_FILE" | awk '{print $5}')
    log_info "Storage backup complete: $BACKUP_FILE ($SIZE)"
}

# Restore storage files
cmd_storage_restore() {
    BACKUP_FILE="$1"

    if [ -z "$BACKUP_FILE" ]; then
        log_error "Usage: $0 storage-restore <backup-file>"
        exit 1
    fi

    if [ ! -f "$BACKUP_FILE" ]; then
        log_error "Backup file not found: $BACKUP_FILE"
        exit 1
    fi

    log_warn "WARNING: This will OVERWRITE current storage files!"
    read -p "Continue? (y/N) " -n 1 -r
    echo

    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "Restore cancelled"
        exit 0
    fi

    log_info "Restoring storage files..."
    tar -xzf "$BACKUP_FILE" -C /opt/supabase/volumes

    log_info "Storage restore complete!"
}

# Main
case "${1:-help}" in
    backup)          cmd_backup ;;
    restore)         cmd_restore "$2" ;;
    list)            cmd_list ;;
    storage-backup)  cmd_storage_backup ;;
    storage-restore) cmd_storage_restore "$2" ;;
    *)
        echo "Supabase Backup/Restore Script"
        echo ""
        echo "Usage: $0 <command>"
        echo ""
        echo "Commands:"
        echo "  backup              Create manual database backup"
        echo "  restore <file>      Restore from backup file"
        echo "  list                List available backups"
        echo "  storage-backup      Backup storage files"
        echo "  storage-restore     Restore storage files"
        exit 1
        ;;
esac
```

Make script executable.
  </action>
  <verify>bash -n production/backup.sh && chmod +x production/backup.sh && echo "Script valid and executable"</verify>
  <done>backup.sh provides backup/restore/list commands for database and storage</done>
</task>

<task type="auto">
  <name>Task 3: Create backup/restore documentation</name>
  <files>docs/BACKUP_RESTORE.md</files>
  <action>
Create docs/BACKUP_RESTORE.md with comprehensive backup and restore documentation.

```markdown
# Supabase Backup and Restore Guide

This document covers backup and restore procedures for the self-hosted Supabase deployment.

## Backup Strategy Overview

| Component | Method | Schedule | Retention |
|-----------|--------|----------|-----------|
| PostgreSQL Database | kartoza/pg-backup | Daily 2 AM | 7 days |
| Storage Files | Manual tar backup | Before updates | 7 days |
| Configuration | Git repository | On change | Unlimited |

## Automated Backups

### How It Works

The `kartoza/pg-backup` container runs alongside Supabase and automatically:
1. Executes pg_dump at 2 AM daily
2. Compresses backups with gzip
3. Removes backups older than 7 days
4. Stores backups in `/opt/backups/postgres/`

### Deploy Automated Backup

```bash
# On the VM:
cd /opt/supabase
docker compose -f docker-compose.backup.yml up -d

# Verify backup container is running
docker ps | grep backup
```

### Verify Backups

```bash
# List backup files
ls -lh /opt/backups/postgres/

# Check backup container logs
docker logs supabase-db-backup
```

## Manual Backup

### Database Backup

```bash
cd /opt/supabase
./backup.sh backup
```

Creates: `/opt/backups/postgres/manual-backup-YYYYMMDD-HHMMSS.sql.gz`

### Storage Backup

```bash
./backup.sh storage-backup
```

Creates: `/opt/backups/postgres/storage-backup-YYYYMMDD-HHMMSS.tar.gz`

### List Available Backups

```bash
./backup.sh list
```

## Restore Procedures

### Database Restore

**WARNING:** This will OVERWRITE all current data!

1. **Stop all traffic** (optional but recommended):
   - Update DNS to maintenance page, or
   - Stop frontend containers

2. **Perform restore**:
   ```bash
   cd /opt/supabase

   # List available backups
   ./backup.sh list

   # Restore from specific backup
   ./backup.sh restore manual-backup-20260129-020000.sql.gz
   ```

3. **Verify data**:
   - Check Supabase Studio for tables
   - Test API endpoints
   - Verify user authentication works

4. **Resume traffic**

### Storage Restore

```bash
./backup.sh storage-restore storage-backup-20260129-020000.tar.gz
```

### Point-in-Time Recovery

The automated backups are full dumps. For point-in-time recovery:
1. Restore the most recent backup BEFORE the incident
2. Accept data loss between backup and incident

For mission-critical deployments, consider:
- More frequent automated backups (hourly)
- PostgreSQL WAL archiving for true point-in-time recovery

## Disaster Recovery

### Complete VM Loss

1. Create new Proxmox VM following `docs/PROXMOX_VM_SETUP.md`
2. Run vm-setup.sh
3. Copy production configuration files
4. Configure .env with SAME secrets as original
5. Deploy Supabase and Caddy
6. Restore database from backup
7. Restore storage files
8. Verify OAuth and API access

### Database Corruption

1. Stop Supabase: `./deploy.sh stop`
2. Remove database volume: `docker volume rm supabase_db_data`
3. Start Supabase: `./deploy.sh start`
4. Restore from backup: `./backup.sh restore <file>`
5. Apply any missing migrations

## Off-Site Backup

For additional protection, copy backups off the VM:

```bash
# From your local machine or another server:
rsync -avz user@vm-ip:/opt/backups/postgres/ /path/to/offsite/backup/

# Or use rclone to sync to cloud storage:
rclone sync /opt/backups/postgres remote:supabase-backups
```

Recommended: Set up a cron job on another machine to pull backups daily.

## Testing Backups

**Backups are only useful if they restore successfully.**

Monthly testing procedure:
1. Create a test VM (or use local Docker)
2. Deploy Supabase with same configuration
3. Restore backup
4. Verify data integrity
5. Document any issues

## Backup Monitoring

### Check Last Backup

```bash
# Most recent backup file
ls -lt /opt/backups/postgres/*.gz | head -1

# Backup container status
docker ps | grep backup
docker logs --tail 20 supabase-db-backup
```

### Alert on Backup Failure

Consider adding monitoring:
- Check backup file age (alert if > 26 hours old)
- Check backup container health
- Integrate with your monitoring system (Prometheus, Grafana, etc.)

## Configuration Backup

Configuration files are stored in git and don't need automated backup:
- `.env.template` (in git)
- `docker-compose.override.yml` (in git)
- `deploy.sh` (in git)

**The only file NOT in git is `.env` (contains secrets).**

Backup `.env` separately:
```bash
# Encrypt and store securely
gpg -c /opt/supabase/.env
# Store encrypted file in password manager or secure location
```
```
  </action>
  <verify>grep -c "Restore" docs/BACKUP_RESTORE.md (should be >= 10)</verify>
  <done>BACKUP_RESTORE.md provides comprehensive backup and restore documentation including disaster recovery</done>
</task>

</tasks>

<verification>
- [ ] docker-compose.backup.yml is valid and connects to Supabase network
- [ ] backup.sh is executable and passes syntax check
- [ ] BACKUP_RESTORE.md covers automated backup, manual backup/restore, and disaster recovery
</verification>

<success_criteria>
- Automated backup runs daily with 7-day retention
- Manual backup/restore scripts work for database and storage
- Documentation covers all backup/restore scenarios including disaster recovery
</success_criteria>

<output>
After completion, create `.planning/phases/04-production-infrastructure/04-05-SUMMARY.md`
</output>
