---
phase: 05-deployment-reconfiguration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - Dockerfile.frontend
  - nginx.conf
autonomous: true

must_haves:
  truths:
    - "Frontend container builds successfully with React production build"
    - "Nginx serves static files without proxying /api requests"
    - "Frontend container has health check and runs as non-root user"
  artifacts:
    - path: "Dockerfile.frontend"
      provides: "Multi-stage frontend build with security hardening"
      contains: "HEALTHCHECK"
    - path: "nginx.conf"
      provides: "Static file serving without API proxying"
      contains: "try_files"
  key_links:
    - from: "Dockerfile.frontend"
      to: "nginx.conf"
      via: "COPY nginx.conf into container"
      pattern: "COPY nginx.conf"
    - from: "nginx.conf"
      to: "Traefik ingress"
      via: "Absence of /api proxy - Traefik handles API routing"
      pattern: "NO proxy_pass"
---

<objective>
Update the frontend Dockerfile and nginx.conf for the split architecture where Traefik handles API routing.

Purpose: The frontend container must serve ONLY static files. API routing (/api -> backend VM) is handled by Traefik ingress on k3s, NOT by nginx inside the frontend container. The existing nginx.conf contains `proxy_pass http://backend-service:3001` for /api which will BREAK in the split architecture because backend-service will no longer be a k8s pod but an external VM. Nginx cannot resolve the backend hostname, and even if it could, double-proxying (nginx -> Traefik -> VM) is wasteful.

Output: Updated Dockerfile.frontend with security hardening and health check, cleaned nginx.conf with API proxy removed.
</objective>

<execution_context>
@/home/logan/.claude/get-shit-done/workflows/execute-plan.md
@/home/logan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-deployment-reconfiguration/05-RESEARCH.md

@Dockerfile.frontend
@nginx.conf
@.env.template
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update nginx.conf - Remove API proxying, keep static serving</name>
  <files>nginx.conf</files>
  <action>
Rewrite nginx.conf to remove ALL /api proxy_pass configuration. The frontend container should ONLY serve static files. Traefik ingress will handle routing /api requests to the backend VM.

Keep:
1. listen 80
2. server_name _
3. Root location (/) serving from /usr/share/nginx/html with try_files $uri $uri/ /index.html (required for React Router / hash-based routing)
4. Gzip compression settings (gzip on, gzip_vary, gzip_min_length, gzip_types)
5. Security headers (X-Frame-Options, X-XSS-Protection, X-Content-Type-Options, Referrer-Policy, Content-Security-Policy)
6. Static asset caching for JS and CSS files (expires 1y, Cache-Control public immutable)

REMOVE entirely:
1. `location /api { proxy_pass http://backend-service:3001; ... }` block
2. `location ~ ^/api.*$ { ... }` preflight/OPTIONS handler block
3. ALL CORS headers from nginx (CORS is handled by the Express backend, not by the reverse proxy)

Why remove CORS from nginx: In the split architecture, the browser makes requests to edwardstech.dev/api. Traefik routes to the backend. The backend Express server handles CORS headers. Having nginx ALSO set CORS headers creates duplicate/conflicting headers that break browsers.

Add a comment at the top: "# Frontend-only nginx config - API routing handled by Traefik ingress"
  </action>
  <verify>
Run `nginx -t -c /path/to/nginx.conf` syntax check (or verify by building the frontend Docker image). Confirm the file does NOT contain "proxy_pass" or "backend-service". Confirm it DOES contain "try_files" and "gzip on".
  </verify>
  <done>nginx.conf serves only static files, contains no API proxy configuration, retains security headers, gzip, and React Router support.</done>
</task>

<task type="auto">
  <name>Task 2: Update Dockerfile.frontend with security hardening and health check</name>
  <files>Dockerfile.frontend</files>
  <action>
Update the existing Dockerfile.frontend multi-stage build. The current file has formatting issues (indentation on RUN npm install) and is missing security best practices.

Build stage (FROM node:18-alpine AS builder):
1. WORKDIR /app
2. COPY package.json package-lock.json ./
3. RUN npm ci (use npm ci, not npm install - for deterministic builds)
4. COPY public/ ./public/
5. COPY src/ ./src/
6. Add build args for environment variables that React needs at build time:
   - ARG REACT_APP_SUPABASE_URL
   - ARG REACT_APP_SUPABASE_ANON_KEY
   - ARG REACT_APP_API_URL
   - ARG REACT_APP_STRIPE_PUBLISHABLE_KEY
7. RUN npm run build

Runtime stage (FROM nginx:alpine):
1. COPY --from=builder /app/build /usr/share/nginx/html
2. COPY nginx.conf /etc/nginx/conf.d/default.conf
3. Security: Set ownership to nginx user (nginx:nginx already exists in nginx:alpine):
   - RUN chown -R nginx:nginx /usr/share/nginx/html
   - RUN chown -R nginx:nginx /var/cache/nginx /var/log/nginx
   - RUN touch /var/run/nginx.pid && chown nginx:nginx /var/run/nginx.pid
4. USER nginx
5. EXPOSE 80
6. HEALTHCHECK --interval=30s --timeout=3s CMD wget --quiet --tries=1 --spider http://localhost/ || exit 1
7. CMD ["nginx", "-g", "daemon off;"]

Note: Using build-time ARGs for REACT_APP_ variables (not runtime injection). The research recommended this simpler approach - accept separate builds per environment. Runtime injection can be added in Phase 6 if GitOps requires it. The ARGs are passed via --build-arg in the build-and-push script (Plan 04).
  </action>
  <verify>
Run `docker build -f Dockerfile.frontend --build-arg REACT_APP_SUPABASE_URL=http://test --build-arg REACT_APP_SUPABASE_ANON_KEY=test --build-arg REACT_APP_API_URL=http://test --build-arg REACT_APP_STRIPE_PUBLISHABLE_KEY=test -t test-frontend:verify .` from repo root. Build should complete successfully. Verify health check with `docker inspect test-frontend:verify --format='{{json .Config.Healthcheck}}'`. Clean up with `docker rmi test-frontend:verify`.
  </verify>
  <done>Dockerfile.frontend builds successfully with multi-stage build, runs as non-root nginx user, has health check, accepts build-time environment variables via ARGs.</done>
</task>

</tasks>

<verification>
1. nginx.conf does NOT contain "proxy_pass" or "backend-service"
2. nginx.conf DOES contain "try_files $uri $uri/ /index.html"
3. nginx.conf DOES contain gzip and security headers
4. Dockerfile.frontend builds successfully with build args
5. Dockerfile.frontend includes HEALTHCHECK and USER nginx
6. No CORS headers in nginx.conf (handled by Express backend)
</verification>

<success_criteria>
- nginx.conf is a pure static file server with no API proxying
- Dockerfile.frontend uses npm ci (not npm install), runs as non-root, has health check
- Build-time environment variables are passed via ARG/--build-arg pattern
- Frontend container builds and serves React app on port 80
</success_criteria>

<output>
After completion, create `.planning/phases/05-deployment-reconfiguration/05-02-SUMMARY.md`
</output>
