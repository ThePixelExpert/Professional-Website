---
phase: 05-deployment-reconfiguration
plan: 04
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - scripts/build-and-push.sh
  - scripts/deploy-backend.sh
  - scripts/deploy-k8s.sh
autonomous: true

must_haves:
  truths:
    - "Build script creates Docker images tagged with git SHA, version, and latest"
    - "Build script pushes both frontend and backend images to self-hosted registry"
    - "Backend deploy script copies compose file and pulls image on VM via SSH"
    - "K8s deploy script applies manifests to Pi cluster and verifies rollout"
  artifacts:
    - path: "scripts/build-and-push.sh"
      provides: "Image build and registry push with git SHA tagging"
      contains: "docker build"
    - path: "scripts/deploy-backend.sh"
      provides: "Backend deployment to Proxmox VM via SSH"
      contains: "192.168.0.50"
    - path: "scripts/deploy-k8s.sh"
      provides: "Frontend deployment to k3s cluster"
      contains: "kubectl apply"
  key_links:
    - from: "scripts/build-and-push.sh"
      to: "Dockerfile.backend"
      via: "docker build -f Dockerfile.backend"
      pattern: "Dockerfile.backend"
    - from: "scripts/build-and-push.sh"
      to: "Dockerfile.frontend"
      via: "docker build -f Dockerfile.frontend"
      pattern: "Dockerfile.frontend"
    - from: "scripts/deploy-backend.sh"
      to: "docker-compose.backend.yml"
      via: "scp to VM"
      pattern: "docker-compose.backend.yml"
    - from: "scripts/deploy-k8s.sh"
      to: "k8s/"
      via: "kubectl apply -f"
      pattern: "kubectl apply"
---

<objective>
Create deployment scripts for the split architecture: build-and-push for both images, deploy-backend for VM, deploy-k8s for Pi cluster.

Purpose: The existing scripts/build-and-deploy.sh deploys BOTH frontend and backend to the k3s cluster (the old monolithic pattern). New scripts are needed for the split architecture where backend goes to Proxmox VM and frontend goes to k3s. The build script must tag images with git SHA for traceability and push to the self-hosted registry at 192.168.0.40:5000.

Output: Three deployment scripts covering build, backend VM deployment, and k8s frontend deployment.
</objective>

<execution_context>
@/home/logan/.claude/get-shit-done/workflows/execute-plan.md
@/home/logan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-deployment-reconfiguration/05-RESEARCH.md

@scripts/build-and-deploy.sh
@Dockerfile.backend
@Dockerfile.frontend
@docker-compose.backend.yml
@.env.template
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create build-and-push script with git SHA tagging</name>
  <files>scripts/build-and-push.sh</files>
  <action>
REPLACE the existing scripts/build-and-push.sh with a new version for the split architecture. The old script deployed everything to k3s via Ansible. The new script only builds and pushes images.

Requirements:
1. #!/bin/bash with set -euo pipefail
2. Navigate to repo root using SCRIPT_DIR pattern (copy from existing script)
3. Define REGISTRY="192.168.0.40:5000"
4. Compute GIT_SHA=$(git rev-parse --short HEAD)
5. Color-coded output (GREEN, YELLOW, RED, NC - copy from existing)
6. Accept optional argument for what to build: "all" (default), "frontend", "backend"

Frontend build:
1. docker build with --platform linux/arm64 (Pi cluster is ARM64) using buildx
2. Pass build args: --build-arg REACT_APP_SUPABASE_URL, REACT_APP_SUPABASE_ANON_KEY, REACT_APP_API_URL, REACT_APP_STRIPE_PUBLISHABLE_KEY
3. Read these values from a .env.production file in repo root (source it). If .env.production doesn't exist, warn and exit with instructions.
4. Tags: ${REGISTRY}/frontend:${GIT_SHA}, ${REGISTRY}/frontend:latest
5. Push both tags

Backend build:
1. docker build with --platform linux/amd64 (Proxmox VM is x86_64) using buildx
2. Tags: ${REGISTRY}/backend:${GIT_SHA}, ${REGISTRY}/backend:latest
3. Push both tags

After build:
1. Print summary of images built and their tags
2. Clean up local Docker build cache (docker builder prune -f)
3. Registry cleanup: keep last 5 tags for each image (copy the cleanup logic from existing build-and-deploy.sh, it already works)

Make the script executable.

Important: Use --platform linux/arm64 for frontend (runs on Pi ARM64) and --platform linux/amd64 for backend (runs on Proxmox x86_64). The existing script already uses buildx with --platform, so follow that pattern.
  </action>
  <verify>
Run `bash -n scripts/build-and-push.sh` to syntax check. Verify the script references both Dockerfile.frontend and Dockerfile.backend. Verify it tags with GIT_SHA. Verify it uses --platform linux/arm64 for frontend and --platform linux/amd64 for backend.
  </verify>
  <done>Build script creates multi-platform images tagged with git SHA and latest, pushes to self-hosted registry, cleans up old tags.</done>
</task>

<task type="auto">
  <name>Task 2: Create backend VM deploy script and k8s frontend deploy script</name>
  <files>scripts/deploy-backend.sh, scripts/deploy-k8s.sh</files>
  <action>
**scripts/deploy-backend.sh** - Deploy backend to Proxmox VM:

1. #!/bin/bash with set -euo pipefail
2. Navigate to repo root
3. Define VM_HOST="192.168.0.50", VM_USER="ubuntu" (matches Phase 4 VM setup)
4. Define DEPLOY_DIR="~/backend" on the VM
5. Compute GIT_SHA=$(git rev-parse --short HEAD)
6. Steps:
   a. SSH to create deploy directory: ssh ${VM_USER}@${VM_HOST} "mkdir -p ${DEPLOY_DIR}"
   b. SCP docker-compose.backend.yml to ${DEPLOY_DIR}/docker-compose.yml
   c. SCP contact-backend/.env.production to ${DEPLOY_DIR}/.env (if .env.production exists; if not, warn that it needs to be created from template)
   d. SSH to pull and restart: export GIT_SHA, docker compose pull, docker compose up -d, docker compose ps, docker compose logs --tail=20
   e. Wait 10 seconds then verify health: curl -sf http://localhost:3001/api/health on the VM
7. Print success/failure with the deployed git SHA
8. Make executable

**scripts/deploy-k8s.sh** - Deploy frontend to k3s cluster:

1. #!/bin/bash with set -euo pipefail
2. Navigate to repo root
3. Define PI_HOST="192.168.0.40", PI_USER="pi"
4. Compute GIT_SHA=$(git rev-parse --short HEAD)
5. Steps:
   a. Ensure website namespace exists: kubectl create namespace website --dry-run=client -o yaml | kubectl apply -f -
   b. Apply backend Service+Endpoints: kubectl apply -f k8s/backend/service.yaml -f k8s/backend/endpoints.yaml
   c. Apply frontend deployment: Update image tag in manifest using sed (or kubectl set image), then kubectl apply -f k8s/frontend/deployment.yaml
   d. Apply ingress: kubectl apply -f k8s/ingress.yaml
   e. Wait for rollout: kubectl rollout status deployment/frontend -n website --timeout=120s
   f. Verify pods are running: kubectl get pods -n website
   g. Verify services: kubectl get svc -n website
   h. Verify endpoints: kubectl get endpoints -n website
6. Print summary showing deployed resources
7. Make executable

Note: The k8s deploy script assumes kubectl is configured to talk to the Pi k3s cluster (either via KUBECONFIG or ssh-based kubectl context). The existing build-and-deploy.sh SSHs to the Pi and runs kubectl there. Follow whichever pattern is already configured. Check if kubectl can reach the cluster directly; if not, wrap commands in ssh pi@192.168.0.40.

For updating the image tag, use: kubectl set image deployment/frontend frontend=192.168.0.40:5000/frontend:${GIT_SHA} -n website
This is cleaner than sed-ing the YAML file.
  </action>
  <verify>
Run `bash -n scripts/deploy-backend.sh` and `bash -n scripts/deploy-k8s.sh` to syntax check both scripts. Verify deploy-backend.sh references 192.168.0.50 and docker compose commands. Verify deploy-k8s.sh references kubectl apply and rollout status.
  </verify>
  <done>Backend deploy script SSHs to VM, copies compose file, pulls image, restarts, and verifies health. K8s deploy script applies all manifests, updates image tag, and waits for rollout completion.</done>
</task>

</tasks>

<verification>
1. `bash -n scripts/build-and-push.sh` passes syntax check
2. `bash -n scripts/deploy-backend.sh` passes syntax check
3. `bash -n scripts/deploy-k8s.sh` passes syntax check
4. All three scripts are executable (chmod +x)
5. build-and-push.sh uses different --platform for frontend (arm64) vs backend (amd64)
6. deploy-backend.sh targets 192.168.0.50 with docker compose commands
7. deploy-k8s.sh applies all k8s manifests and waits for rollout
</verification>

<success_criteria>
- Build script creates correctly-platformed images for Pi (ARM64) and VM (AMD64)
- Backend deploy script handles full lifecycle: copy, pull, restart, health check
- K8s deploy script applies all manifests and verifies rollout completes
- All scripts have error handling (set -euo pipefail) and informative output
</success_criteria>

<output>
After completion, create `.planning/phases/05-deployment-reconfiguration/05-04-SUMMARY.md`
</output>
