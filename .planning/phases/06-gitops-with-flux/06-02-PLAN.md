---
phase: 06-gitops-with-flux
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - flux/clusters/production/frontend/kustomization.yaml
  - flux/clusters/production/frontend/deployment.yaml
  - flux/clusters/production/frontend/service.yaml
  - flux/clusters/production/frontend/namespace.yaml
autonomous: true

must_haves:
  truths:
    - "Frontend Kubernetes manifests are managed by Flux Kustomization"
    - "Frontend deployment manifest contains Flux image setter comment for automated tag updates"
    - "Frontend manifests create the website namespace and deploy 2 replicas with health probes"
  artifacts:
    - path: "flux/clusters/production/frontend/kustomization.yaml"
      provides: "Kustomize config listing frontend resources"
      contains: "resources:"
    - path: "flux/clusters/production/frontend/deployment.yaml"
      provides: "Frontend Deployment with Flux setter comment"
      contains: "imagepolicy"
    - path: "flux/clusters/production/frontend/service.yaml"
      provides: "Frontend ClusterIP Service"
      contains: "ClusterIP"
  key_links:
    - from: "flux/clusters/production/frontend/deployment.yaml"
      to: "flux-system:frontend"
      via: "Flux image setter comment on image line"
      pattern: 'imagepolicy.*flux-system:frontend'
---

<objective>
Create Flux-managed frontend Kubernetes manifests with Kustomize structure and image setter comments.

Purpose: Flux reconciles Kubernetes resources from git. The frontend manifests must live under the Flux path (flux/clusters/production/) with Kustomize structure so Flux can apply them. The deployment manifest needs a special setter comment on the image line so ImageUpdateAutomation can write new tags back to git.

Output: Complete frontend Kustomize overlay under flux/clusters/production/frontend/ ready for Flux reconciliation.
</objective>

<execution_context>
@/home/logan/.claude/get-shit-done/workflows/execute-plan.md
@/home/logan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-gitops-with-flux/06-RESEARCH.md
@k8s/frontend/deployment.yaml
@k8s/ingress.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create frontend Kustomize manifests with Flux setter comments</name>
  <files>
    flux/clusters/production/frontend/kustomization.yaml
    flux/clusters/production/frontend/namespace.yaml
    flux/clusters/production/frontend/deployment.yaml
    flux/clusters/production/frontend/service.yaml
  </files>
  <action>
    Create the directory `flux/clusters/production/frontend/` and populate it with Flux-managed manifests.

    These are NOT copies of k8s/frontend/* - they are the Flux-managed versions that replace the manual k8s/ manifests. The k8s/ directory remains as reference/fallback for manual deployment.

    1. **flux/clusters/production/frontend/namespace.yaml:**
       ```yaml
       apiVersion: v1
       kind: Namespace
       metadata:
         name: website
       ```

    2. **flux/clusters/production/frontend/deployment.yaml:**
       Based on k8s/frontend/deployment.yaml but with Flux setter comment:
       ```yaml
       apiVersion: apps/v1
       kind: Deployment
       metadata:
         name: frontend
         namespace: website
         labels:
           app: frontend
       spec:
         replicas: 2
         strategy:
           type: RollingUpdate
           rollingUpdate:
             maxSurge: 1
             maxUnavailable: 0
         selector:
           matchLabels:
             app: frontend
         template:
           metadata:
             labels:
               app: frontend
           spec:
             containers:
             - name: frontend
               image: 192.168.0.40:5000/frontend:main-placeholder-0000000000 # {"$imagepolicy": "flux-system:frontend"}
               imagePullPolicy: Always
               ports:
               - containerPort: 80
               resources:
                 requests:
                   memory: "64Mi"
                   cpu: "50m"
                 limits:
                   memory: "128Mi"
                   cpu: "100m"
               readinessProbe:
                 httpGet:
                   path: /
                   port: 80
                 initialDelaySeconds: 10
                 periodSeconds: 5
               livenessProbe:
                 httpGet:
                   path: /
                   port: 80
                 initialDelaySeconds: 15
                 periodSeconds: 20
               volumeMounts:
               - name: cache
                 mountPath: /var/cache/nginx
               - name: run
                 mountPath: /var/run
             volumes:
             - name: cache
               emptyDir: {}
             - name: run
               emptyDir: {}
       ```

       CRITICAL: The image line MUST end with the exact comment `# {"$imagepolicy": "flux-system:frontend"}` on the same line as the image value. This is how Flux ImageUpdateAutomation identifies which lines to update with new tags. The placeholder tag `main-placeholder-0000000000` follows the sortable format and will be replaced by Flux on first automation run.

       Note the readinessProbe initialDelaySeconds is set to 10 (up from 5 in the old manifest) with periodSeconds 5 for faster detection. This gives the React app time to cold-start on Pi hardware.

    3. **flux/clusters/production/frontend/service.yaml:**
       ```yaml
       apiVersion: v1
       kind: Service
       metadata:
         name: frontend-service
         namespace: website
       spec:
         selector:
           app: frontend
         ports:
           - protocol: TCP
             port: 80
             targetPort: 80
         type: ClusterIP
       ```

    4. **flux/clusters/production/frontend/kustomization.yaml:**
       ```yaml
       apiVersion: kustomize.config.k8s.io/v1beta1
       kind: Kustomization
       resources:
         - namespace.yaml
         - deployment.yaml
         - service.yaml
       ```

    Do NOT include the ingress in the frontend kustomization. Ingress will be handled separately (it routes to both frontend and backend services, so it belongs at a higher level or in its own directory).
  </action>
  <verify>
    Verify files exist: `ls flux/clusters/production/frontend/`
    Verify setter comment: `grep 'imagepolicy' flux/clusters/production/frontend/deployment.yaml`
    Verify kustomization lists all resources: `grep -A5 'resources:' flux/clusters/production/frontend/kustomization.yaml`
    Validate YAML: `python3 -c "import yaml; [yaml.safe_load(open(f)) for f in ['flux/clusters/production/frontend/kustomization.yaml', 'flux/clusters/production/frontend/namespace.yaml', 'flux/clusters/production/frontend/deployment.yaml', 'flux/clusters/production/frontend/service.yaml']]"`
  </verify>
  <done>
    Frontend Kustomize manifests exist at flux/clusters/production/frontend/ with Flux image setter comment on the deployment image line. Kustomization references all 3 resources (namespace, deployment, service).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ingress manifest under Flux management</name>
  <files>
    flux/clusters/production/ingress/kustomization.yaml
    flux/clusters/production/ingress/ingress.yaml
  </files>
  <action>
    Create `flux/clusters/production/ingress/` directory with the split-architecture routing ingress.

    1. **flux/clusters/production/ingress/ingress.yaml:**
       Copy the content from k8s/ingress.yaml verbatim (both the API ingress and frontend ingress resources). This is routing config, not something Flux image automation touches. Keep the exact same Traefik annotations and routing rules.

    2. **flux/clusters/production/ingress/kustomization.yaml:**
       ```yaml
       apiVersion: kustomize.config.k8s.io/v1beta1
       kind: Kustomization
       resources:
         - ingress.yaml
       ```

    The ingress is separate from frontend because it references both frontend-service and backend-service. It does not need setter comments (no image references).
  </action>
  <verify>
    Verify files exist: `ls flux/clusters/production/ingress/`
    Verify both ingress resources present: `grep 'kind: Ingress' flux/clusters/production/ingress/ingress.yaml | wc -l` should be 2
    Verify routing: `grep 'backend-service' flux/clusters/production/ingress/ingress.yaml` and `grep 'frontend-service' flux/clusters/production/ingress/ingress.yaml`
  </verify>
  <done>
    Ingress manifests under Flux management with split-architecture routing: /api to backend-service:3001, / to frontend-service:80. Both edwardstech.dev and www.edwardstech.dev hosts configured.
  </done>
</task>

</tasks>

<verification>
- `ls flux/clusters/production/frontend/` shows 4 files (kustomization, namespace, deployment, service)
- `ls flux/clusters/production/ingress/` shows 2 files (kustomization, ingress)
- Setter comment present: `grep 'imagepolicy' flux/clusters/production/frontend/deployment.yaml`
- All YAML files parse without errors
- Frontend deployment specifies 2 replicas, health probes, Pi-appropriate resources
</verification>

<success_criteria>
- Flux-managed frontend manifests exist with proper Kustomize structure
- Deployment contains image setter comment for Flux ImageUpdateAutomation
- Ingress routes /api to backend and / to frontend
- All manifests are valid YAML
</success_criteria>

<output>
After completion, create `.planning/phases/06-gitops-with-flux/06-02-SUMMARY.md`
</output>
