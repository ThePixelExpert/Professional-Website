# Phase 6: GitOps with Flux - Research

**Researched:** 2026-02-07
**Domain:** Flux CD v2 GitOps, Kubernetes continuous delivery, image automation, split-architecture deployment
**Confidence:** MEDIUM-HIGH

## Summary

This phase introduces Flux CD v2.7.x to automate deployments for a split architecture: frontend on k3s (Raspberry Pi ARM64 cluster) and backend on a Proxmox VM (AMD64). The research covers Flux installation with image automation controllers, Kustomize-based manifest management, automated image tag updates via ImagePolicy/ImageUpdateAutomation, Sealed Secrets for encrypted secret management, and a post-deploy Job pattern for backend VM deployment.

The critical architectural discovery is that Flux is Kubernetes-native and cannot directly manage the backend VM. The CONTEXT.md pattern of "Flux updates docker-compose.yml in git with new SHA, VM pulls via git sync" is viable: Flux's image automation controller can update ANY YAML file in the repo (not just Kubernetes manifests) using setter comments. However, the VM-side git sync requires a separate mechanism -- either a systemd timer polling git, or a Kubernetes Job that SSHes to the VM after image automation commits.

A second critical finding is that the current build script uses pure git SHA tags (`abc1234`) which are NOT sortable by Flux ImagePolicy. Tags must include a timestamp component (e.g., `main-abc1234-1707300000`) for Flux to determine which image is newest.

**Primary recommendation:** Use Flux bootstrap with `--components-extra=image-reflector-controller,image-automation-controller` and `--read-write-key` on the existing GitHub repo. Restructure image tags to include timestamps. Use a Kubernetes post-deploy Job with SSH to trigger backend VM updates after Flux commits new image tags to docker-compose.yml.

## Standard Stack

The established tools for this domain:

### Core
| Tool | Version | Purpose | Why Standard |
|------|---------|---------|--------------|
| Flux CD | v2.7.x | GitOps controller suite | CNCF graduated project, GA image automation, multi-arch support including ARM64 |
| Kustomize | Built into Flux | Manifest overlays and patches | Native Flux integration via kustomize-controller, no Helm needed for plain manifests |
| Sealed Secrets | v0.34.x | Encrypt secrets for git storage | Bitnami-maintained, Flux has official guide, ARM64 controller image available |
| kubeseal | v0.34.x | CLI to create SealedSecrets | Companion to Sealed Secrets controller, ARM64 binaries available |

### Flux Controllers (installed via bootstrap)
| Controller | Purpose | When Active |
|------------|---------|-------------|
| source-controller | Fetches git repos, watches for changes | Always - polls/receives webhooks for git changes |
| kustomize-controller | Applies Kustomize manifests to cluster | Always - reconciles k8s state from git |
| notification-controller | Sends alerts, receives webhooks | Always - handles Harbor/GitHub webhooks and alerts |
| image-reflector-controller | Scans Harbor registry for new tags | Always - polls registry at configured interval |
| image-automation-controller | Commits updated image tags back to git | On new image - updates manifests and docker-compose.yml |

### Supporting
| Tool | Version | Purpose | When to Use |
|------|---------|---------|-------------|
| Flux CLI | v2.7.x | Bootstrap, debug, manage Flux | Installation, troubleshooting, manual reconciliation |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Sealed Secrets | SOPS + age | SOPS is more flexible but requires more setup; Sealed Secrets is simpler for homelab |
| Flux | ArgoCD | ArgoCD has UI but is heavier on resources; Flux is lighter for Pi cluster RAM constraints |
| Post-deploy Job for VM | Systemd timer on VM | Timer is simpler but adds polling delay; Job gives event-driven deployment |

### Installation

On a machine with kubectl access to the k3s cluster:

```bash
# Install Flux CLI (Linux)
curl -s https://fluxcd.io/install.sh | sudo bash

# Or via package manager
# Arch Linux: yay -S flux-bin

# Verify prerequisites
flux check --pre

# Bootstrap with image automation on existing GitHub repo
export GITHUB_TOKEN=<personal-access-token>
flux bootstrap github \
  --owner=ThePixelExpert \
  --repository=Professional-Website \
  --branch=master \
  --path=clusters/pi-cluster \
  --personal \
  --read-write-key \
  --components-extra=image-reflector-controller,image-automation-controller
```

Sealed Secrets installed via Flux HelmRelease (see Code Examples section).

## Architecture Patterns

### Recommended Project Structure

```
Professional-Website/
├── clusters/
│   └── pi-cluster/              # Flux bootstrap path (cluster-level Kustomizations)
│       ├── flux-system/         # Auto-generated by bootstrap
│       ├── apps.yaml            # Flux Kustomization pointing to apps/
│       ├── infrastructure.yaml  # Flux Kustomization pointing to infrastructure/
│       └── image-automation.yaml # ImageRepository, ImagePolicy, ImageUpdateAutomation
├── infrastructure/
│   └── sealed-secrets/          # Sealed Secrets HelmRelease + HelmRepository
│       ├── kustomization.yaml
│       ├── helmrepository.yaml
│       └── helmrelease.yaml
├── apps/
│   ├── frontend/                # Frontend k8s manifests (existing k8s/frontend/)
│   │   ├── kustomization.yaml
│   │   ├── deployment.yaml      # With image policy setter comment
│   │   └── service.yaml
│   ├── backend-routing/         # Backend Service+Endpoints (existing k8s/backend/)
│   │   ├── kustomization.yaml
│   │   ├── service.yaml
│   │   └── endpoints.yaml
│   ├── ingress/                 # Traefik Ingress (existing k8s/ingress.yaml)
│   │   ├── kustomization.yaml
│   │   └── ingress.yaml
│   └── post-deploy/             # Post-deploy Job for backend VM update
│       ├── kustomization.yaml
│       └── backend-deploy-job.yaml
├── docker-compose.backend.yml   # With image policy setter comment for backend
├── k8s/                         # Migrate to apps/ structure (or symlink)
├── scripts/
│   └── build-and-push.sh        # Modified to use timestamp-based tags
└── Dockerfile.frontend
```

### Pattern 1: Image Automation Pipeline (Frontend on k3s)

**What:** Flux watches Harbor registry for new frontend image tags, updates deployment.yaml in git, then reconciles the cluster.
**When to use:** Every push to main that builds a new frontend image.

Flow:
1. CI builds and pushes `192.168.0.40:5000/frontend:main-abc1234-1707300000` to Harbor
2. `ImageRepository` scans Harbor every 1-5 minutes (or Harbor webhook triggers immediate scan)
3. `ImagePolicy` with numerical filter selects newest tag by timestamp
4. `ImageUpdateAutomation` updates `apps/frontend/deployment.yaml` image tag and commits to git
5. `source-controller` detects new commit (or GitHub webhook triggers immediate sync)
6. `kustomize-controller` applies updated deployment to k3s cluster

### Pattern 2: Backend VM Deployment via Git + Post-Deploy Job

**What:** Flux updates docker-compose.backend.yml with new backend image tag in git, then a Kubernetes Job SSHes to the VM to pull and restart.
**When to use:** Every push to main that builds a new backend image.

Flow:
1. CI builds and pushes `192.168.0.40:5000/backend:main-abc1234-1707300000` to Harbor
2. `ImageRepository` scans Harbor for backend images
3. `ImagePolicy` selects newest backend tag by timestamp
4. `ImageUpdateAutomation` updates `docker-compose.backend.yml` image tag AND `apps/post-deploy/backend-deploy-job.yaml` image ref, commits to git
5. `source-controller` detects new commit
6. `kustomize-controller` applies post-deploy Job (with `force: true` to recreate)
7. Job SSHes to 192.168.0.50, runs `git pull && docker compose pull && docker compose up -d`
8. Job health-checks backend at `http://192.168.0.50:3001/api/health`

### Pattern 3: Deployment Staging with Dependencies

**What:** Use Flux Kustomization `dependsOn` to deploy frontend first, wait for health, then deploy backend.
**When to use:** Coordinated frontend + backend deployments.

```yaml
# clusters/pi-cluster/apps.yaml
apiVersion: kustomize.toolkit.fluxcd.io/v1
kind: Kustomization
metadata:
  name: frontend
  namespace: flux-system
spec:
  dependsOn: []  # No dependencies - deploys first
  sourceRef:
    kind: GitRepository
    name: flux-system
  path: ./apps/frontend
  interval: 5m
  timeout: 5m
  prune: true
  wait: true
  healthChecks:
    - apiVersion: apps/v1
      kind: Deployment
      name: frontend
      namespace: website

---
apiVersion: kustomize.toolkit.fluxcd.io/v1
kind: Kustomization
metadata:
  name: backend-deploy
  namespace: flux-system
spec:
  dependsOn:
    - name: frontend  # Waits for frontend health check
  sourceRef:
    kind: GitRepository
    name: flux-system
  path: ./apps/post-deploy
  interval: 5m
  timeout: 5m
  prune: true
  wait: true
  force: true  # Recreate Job on each run
```

### Pattern 4: Rollback via Git Revert

**What:** Flux does NOT automatically roll back on health check failure. Rollback is done by reverting the git commit.
**When to use:** When a deployment fails health checks.

Important: The CONTEXT.md calls for "automatic rollback triggers" but Flux natively only stops progressing dependent Kustomizations on health failure. True automatic rollback requires either:
- A notification Alert that triggers a webhook to a script that runs `git revert`
- A Kubernetes CronJob or controller that monitors Kustomization health and reverts
- Flagger for canary-based automatic rollback (adds complexity)

Recommended approach for homelab: Use Flux Alert with generic webhook to a small rollback handler service running on the cluster that executes `git revert` when health checks fail.

### Anti-Patterns to Avoid

- **Pure git SHA image tags:** Tags like `abc1234` are not sortable. Flux cannot determine which is newest. Always include a timestamp component.
- **Modifying Flux bootstrap manifests manually:** Let `flux bootstrap` manage the `clusters/pi-cluster/flux-system/` directory. Manual edits get overwritten.
- **Putting secrets in git unencrypted:** Always use Sealed Secrets. Even in a private repo, credentials in git are a security risk.
- **Using `latest` tag with image automation:** The `latest` tag is mutable and Flux image automation works with immutable tags. Use specific SHA+timestamp tags.
- **Running Flux on the same SD card as k3s without monitoring:** Flux writes to etcd, adding wear. Monitor SD card health.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Image tag detection | Custom registry polling script | Flux ImageRepository + ImagePolicy | Handles rate limiting, caching, multiple registries, retries |
| Manifest updates | Sed/awk scripts to update YAML | Flux ImageUpdateAutomation with setters | Type-safe, atomic commits, proper YAML handling |
| Secret encryption | Custom encryption wrapper | Sealed Secrets + kubeseal | Battle-tested asymmetric crypto, controller manages keys |
| Deployment ordering | Custom orchestration scripts | Flux Kustomization dependsOn + healthChecks | Declarative, with health-aware dependency resolution |
| Webhook handling | Custom HTTP server for registry events | Flux Receiver CRD | Built-in HMAC validation, rate limiting, resource targeting |
| Git sync polling | Custom cron + git pull | Flux source-controller | Efficient polling with webhook acceleration, error handling |

**Key insight:** Flux provides CRDs for every piece of the GitOps pipeline. The only custom component needed is the backend VM deployment Job and the optional rollback handler, because Flux is Kubernetes-native and cannot SSH to VMs.

## Common Pitfalls

### Pitfall 1: Non-Sortable Image Tags

**What goes wrong:** Flux image automation cannot determine which image is newest because git SHA tags (e.g., `abc1234`) have no chronological ordering.
**Why it happens:** The current `build-and-push.sh` uses `git rev-parse --short HEAD` as the sole tag component.
**How to avoid:** Change tag format to `main-${GIT_SHA}-$(date +%s)` (branch-sha-unix_timestamp). Configure ImagePolicy with `filterTags.pattern` and `numerical` policy on the extracted timestamp.
**Warning signs:** ImagePolicy status shows "no tags match" or picks an incorrect "latest" image.

### Pitfall 2: Insecure Registry Not Configured

**What goes wrong:** ImageRepository fails to scan Harbor at `192.168.0.40:5000` because it defaults to HTTPS.
**Why it happens:** Harbor is running on HTTP (port 5000, no TLS) in the homelab.
**How to avoid:** Set `spec.insecure: true` on the ImageRepository CRD. Also ensure k3s nodes have the registry configured as insecure in `/etc/rancher/k3s/registries.yaml`.
**Warning signs:** ImageRepository status shows TLS handshake errors or connection refused.

### Pitfall 3: Read-Only Deploy Key

**What goes wrong:** ImageUpdateAutomation cannot push commits back to GitHub because the deploy key is read-only.
**Why it happens:** Default Flux bootstrap creates a read-only deploy key. Image automation needs write access.
**How to avoid:** Use `--read-write-key` flag during bootstrap. If already bootstrapped, delete the deploy key secret and re-bootstrap with the flag.
**Warning signs:** ImageUpdateAutomation status shows "authentication required" or "permission denied" on push.

### Pitfall 4: Flux Controllers OOM on Raspberry Pi

**What goes wrong:** Flux controller pods get OOMKilled on Pi nodes with 4GB RAM.
**Why it happens:** Default memory limits may be too high for Pi, or too many resources being reconciled frequently.
**How to avoid:** After bootstrap, patch controller deployments to set appropriate resource limits. Use longer reconciliation intervals (5m+ instead of 1m) to reduce memory pressure.
**Warning signs:** Pods in CrashLoopBackOff with OOMKilled exit code.

### Pitfall 5: Image Automation Commits Trigger Infinite Loop

**What goes wrong:** Flux commits an updated image tag to git, which triggers a new reconciliation, which triggers image scanning, which sees the same image, which tries to commit again.
**Why it happens:** Poor configuration of reconciliation intervals or missing commit message filtering.
**How to avoid:** Flux image automation is designed to handle this -- it only commits when the image tag actually changes. However, if using webhook receivers for GitHub push events, ensure the Receiver has appropriate filters to ignore commits from the Flux bot user.
**Warning signs:** Rapid successive commits from the Flux bot user, high CPU on controllers.

### Pitfall 6: Backend VM Deployment Job Credentials

**What goes wrong:** The Kubernetes Job that SSHes to the backend VM fails because SSH keys are not available or are incorrectly mounted.
**Why it happens:** SSH private key must be stored as a Sealed Secret and mounted into the Job pod.
**How to avoid:** Create an SSH key pair, store the private key as a Sealed Secret, add the public key to the VM's `authorized_keys`. Mount the secret as a volume in the Job spec.
**Warning signs:** Job logs show "Permission denied (publickey)" or "Host key verification failed".

### Pitfall 7: Rollback Expectations vs Reality

**What goes wrong:** User expects automatic rollback on health check failure, but Flux only marks the Kustomization as failed and stops progressing.
**Why it happens:** Flux explicitly does NOT do automatic rollback (confirmed by maintainers). It deploys whatever is at HEAD of the configured branch.
**How to avoid:** Implement a lightweight rollback handler: a generic webhook Alert that triggers a script to `git revert HEAD && git push` when a Kustomization health check fails. Or accept manual `git revert` as the rollback mechanism for homelab simplicity.
**Warning signs:** Failed deployment stays deployed indefinitely, no automatic recovery.

## Code Examples

### ImageRepository for Harbor (Insecure Private Registry)

```yaml
# Source: https://fluxcd.io/flux/components/image/imagerepositories/
apiVersion: image.toolkit.fluxcd.io/v1
kind: ImageRepository
metadata:
  name: frontend
  namespace: flux-system
spec:
  image: 192.168.0.40:5000/frontend
  interval: 1m
  insecure: true  # HTTP registry, no TLS
```

### ImagePolicy for Timestamp-Based Tags

```yaml
# Source: https://fluxcd.io/flux/components/image/imagepolicies/
apiVersion: image.toolkit.fluxcd.io/v1
kind: ImagePolicy
metadata:
  name: frontend
  namespace: flux-system
spec:
  imageRepositoryRef:
    name: frontend
  filterTags:
    pattern: '^main-[a-f0-9]+-(?P<ts>[0-9]+)$'
    extract: '$ts'
  policy:
    numerical:
      order: asc  # Highest timestamp = newest
```

### ImageUpdateAutomation

```yaml
# Source: https://fluxcd.io/flux/components/image/imageupdateautomations/
apiVersion: image.toolkit.fluxcd.io/v1
kind: ImageUpdateAutomation
metadata:
  name: flux-system
  namespace: flux-system
spec:
  interval: 30m
  sourceRef:
    kind: GitRepository
    name: flux-system
  git:
    checkout:
      ref:
        branch: master
    commit:
      author:
        email: fluxbot@edwardstech.dev
        name: Flux Bot
      messageTemplate: |
        chore(deploy): update images

        {{range .Changed.Changes}}
        - {{.OldValue}} -> {{.NewValue}}
        {{end}}
    push:
      branch: master
  update:
    path: ./  # Scan entire repo (finds both k8s manifests and docker-compose.yml)
    strategy: Setters
```

### Frontend Deployment with Setter Comment

```yaml
# apps/frontend/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: website
spec:
  template:
    spec:
      containers:
      - name: frontend
        image: 192.168.0.40:5000/frontend:main-abc1234-1707300000 # {"$imagepolicy": "flux-system:frontend"}
        # The setter comment tells Flux to update this line with the latest tag
```

### Docker-Compose with Setter Comment (Backend)

```yaml
# docker-compose.backend.yml
version: '3.8'
services:
  backend:
    image: 192.168.0.40:5000/backend:main-abc1234-1707300000 # {"$imagepolicy": "flux-system:backend"}
    container_name: edwards-backend
    # ... rest of config
```

### Backend Deploy Job (SSH to VM)

```yaml
# apps/post-deploy/backend-deploy-job.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: backend-deploy
  namespace: website
spec:
  backoffLimit: 2
  ttlSecondsAfterFinished: 300
  template:
    spec:
      restartPolicy: Never
      containers:
      - name: deploy
        image: alpine:3.19
        command:
          - /bin/sh
          - -c
          - |
            apk add --no-cache openssh-client curl
            mkdir -p ~/.ssh
            cp /ssh-key/id_ed25519 ~/.ssh/id_ed25519
            chmod 600 ~/.ssh/id_ed25519
            ssh-keyscan -H 192.168.0.50 >> ~/.ssh/known_hosts

            # Pull latest git changes and restart backend
            ssh -o StrictHostKeyChecking=accept-new deploy@192.168.0.50 << 'REMOTE'
              cd /opt/Professional-Website
              git pull origin master
              docker compose -f docker-compose.backend.yml pull
              docker compose -f docker-compose.backend.yml up -d
            REMOTE

            # Health check (wait up to 60s)
            for i in $(seq 1 12); do
              if curl -sf http://192.168.0.50:3001/api/health; then
                echo "Backend healthy"
                exit 0
              fi
              sleep 5
            done
            echo "Backend health check failed"
            exit 1
        volumeMounts:
        - name: ssh-key
          mountPath: /ssh-key
          readOnly: true
      volumes:
      - name: ssh-key
        secret:
          secretName: backend-deploy-ssh-key  # SealedSecret-managed
          defaultMode: 0400
```

### Sealed Secrets via Flux HelmRelease

```yaml
# infrastructure/sealed-secrets/helmrepository.yaml
apiVersion: source.toolkit.fluxcd.io/v1
kind: HelmRepository
metadata:
  name: sealed-secrets
  namespace: flux-system
spec:
  interval: 1h
  url: https://bitnami-labs.github.io/sealed-secrets

---
# infrastructure/sealed-secrets/helmrelease.yaml
apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: sealed-secrets
  namespace: flux-system
spec:
  interval: 1h
  releaseName: sealed-secrets-controller
  chart:
    spec:
      chart: sealed-secrets
      version: ">=2.0.0"
      sourceRef:
        kind: HelmRepository
        name: sealed-secrets
  values:
    fullnameOverride: sealed-secrets-controller
```

### Alert for Deployment Failures (Generic Webhook)

```yaml
# Source: https://fluxcd.io/flux/components/notification/providers/
apiVersion: notification.toolkit.fluxcd.io/v1beta3
kind: Provider
metadata:
  name: deployment-webhook
  namespace: flux-system
spec:
  type: generic
  address: http://rollback-handler.website.svc.cluster.local/webhook

---
apiVersion: notification.toolkit.fluxcd.io/v1beta3
kind: Alert
metadata:
  name: deployment-failures
  namespace: flux-system
spec:
  providerRef:
    name: deployment-webhook
  eventSeverity: error
  eventSources:
    - kind: Kustomization
      name: frontend
    - kind: Kustomization
      name: backend-deploy
```

### Updated Build Script Tag Format

```bash
# In scripts/build-and-push.sh, change tag format:
BRANCH=$(git rev-parse --abbrev-ref HEAD | sed 's/[^a-zA-Z0-9]/-/g')
GIT_SHA=$(git rev-parse --short HEAD)
TIMESTAMP=$(date +%s)
TAG="${BRANCH}-${GIT_SHA}-${TIMESTAMP}"

# Build with sortable tag:
docker buildx build \
  --platform linux/arm64 \
  -t "${REGISTRY}/frontend:${TAG}" \
  --push .
```

### Harbor Webhook Receiver (Optional - Reduces Polling Delay)

```yaml
# Source: https://fluxcd.io/flux/guides/webhook-receivers/
apiVersion: notification.toolkit.fluxcd.io/v1
kind: Receiver
metadata:
  name: harbor
  namespace: flux-system
spec:
  type: harbor
  secretRef:
    name: harbor-webhook-token
  resources:
    - kind: ImageRepository
      name: frontend
    - kind: ImageRepository
      name: backend
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Flux v1 (fluxcd/flux) | Flux v2 (fluxcd/flux2) | 2020-2021 | Complete rewrite, CRD-based, modular controllers |
| Image automation beta APIs | GA APIs (image.toolkit.fluxcd.io/v1) | Flux v2.7 (Sept 2025) | Stable, production-ready image automation |
| Select latest by build time | Sortable tags with timestamp | Flux v2.0+ | Build-time scanning deprecated due to registry rate limiting |
| Manual secret management | Sealed Secrets / SOPS | Ongoing | Secrets safe in git, GitOps-native |
| Push-based CI/CD scripts | Pull-based GitOps with Flux | Ongoing | Git as single source of truth, automatic drift correction |

**Deprecated/outdated:**
- **Flux v1:** Completely superseded by Flux v2. Do not use.
- **Image build-time scanning:** Deprecated in favor of sortable tags. Registries rate-limit metadata requests.
- **`latest` tag for automation:** Mutable tags defeat GitOps principles. Use immutable SHA+timestamp tags.

## Open Questions

1. **Build infrastructure for CI**
   - What we know: CONTEXT.md says "Build location: Claude's discretion (choose based on infrastructure constraints)." Options are: dev machine, a VM on Proxmox, or GitHub Actions.
   - What's unclear: Whether the dev machine has Docker buildx with multi-arch support already configured, and whether GitHub Actions free tier has enough minutes.
   - Recommendation: Use the dev machine or a dedicated Proxmox VM for builds initially (keeps everything local to homelab). Can be migrated to GitHub Actions later. The build script already uses `docker buildx` which implies cross-platform build capability exists.

2. **Sealed Secrets controller ARM64 compatibility**
   - What we know: kubeseal CLI has ARM64 binaries. The Helm chart deploys the controller.
   - What's unclear: Whether the sealed-secrets controller Docker image includes ARM64 variant. Historical issues existed but recent versions (v0.34.x) likely support it.
   - Recommendation: Verify ARM64 image availability during implementation. If not available, build from source or use SOPS+age as fallback.

3. **Automatic rollback implementation complexity**
   - What we know: Flux does NOT automatically roll back. The CONTEXT.md specifies "Git revert" as rollback method with "automatic rollback triggers on failed health checks."
   - What's unclear: How complex the rollback handler needs to be. A simple webhook handler that runs `git revert HEAD && git push` might cause issues if multiple commits occurred.
   - Recommendation: Start with manual `git revert` for v1.0 (homelab simplicity). Document the automatic rollback handler as a v1.1 enhancement. Flux's dependency chain (`dependsOn`) already prevents cascading failures.

4. **Git sync interval vs webhook-driven updates**
   - What we know: Flux polls git at configurable intervals (default 1m). Webhook receivers can trigger immediate reconciliation.
   - What's unclear: Whether the homelab's network setup supports webhook callbacks from GitHub to the k3s cluster (requires port forwarding or Cloudflare tunnel).
   - Recommendation: Start with polling (1m interval for source, 1m for image scanning). Add webhook receivers later if latency is unacceptable.

5. **Where CI triggers live**
   - What we know: Need something to trigger `build-and-push.sh` on push to main. Options: GitHub Actions, local git hook, manual.
   - What's unclear: Whether the user wants fully automated CI (GitHub Actions) or semi-automated (manual script run).
   - Recommendation: Create a GitHub Actions workflow that runs on push to master, executes `build-and-push.sh` via self-hosted runner on the homelab (avoids ARM64 cross-compilation on GitHub's AMD64 runners).

## Sources

### Primary (HIGH confidence)
- Flux CD official documentation (https://fluxcd.io/flux/) - installation, components, guides
- Flux image automation guide (https://fluxcd.io/flux/guides/image-update/) - ImageRepository, ImagePolicy, ImageUpdateAutomation CRDs
- Flux sortable image tags guide (https://fluxcd.io/flux/guides/sortable-image-tags/) - tag format requirements
- Flux running jobs use case (https://fluxcd.io/flux/use-cases/running-jobs/) - post-deploy Job pattern
- Flux Kustomization CRD (https://fluxcd.io/flux/components/kustomize/kustomizations/) - health checks, dependencies, timeouts
- Flux sealed secrets guide (https://fluxcd.io/flux/guides/sealed-secrets/) - installation and usage
- Flux notification providers (https://fluxcd.io/flux/components/notification/providers/) - Alert and Provider CRDs
- Flux bootstrap github (https://fluxcd.io/flux/cmd/flux_bootstrap_github/) - --read-write-key flag
- Flux optional components (https://fluxcd.io/flux/installation/configuration/optional-components/) - --components-extra flag

### Secondary (MEDIUM confidence)
- Flux v2.7 GA announcement (https://fluxcd.io/blog/2025/09/flux-v2.7.0/) - image automation GA status
- GitHub fluxcd/flux2 discussions (#2916) - rollback behavior confirmed by maintainers
- Sealed Secrets releases (https://github.com/bitnami-labs/sealed-secrets/releases) - v0.34.0, ARM64 support
- Flux webhook receivers guide (https://fluxcd.io/flux/guides/webhook-receivers/) - Harbor receiver type

### Tertiary (LOW confidence)
- Community homelab guides for Flux + k3s + Pi (Medium articles, dev.to) - general patterns
- Docker-compose setter comment support - confirmed by documentation that image automation "does not examine or patch running kubernetes resources" but only patches repo files, suggesting docker-compose.yml works with setter comments

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Flux v2.7.x is CNCF graduated, well-documented, image automation at GA
- Architecture patterns: MEDIUM-HIGH - Patterns from official docs, but the docker-compose setter and SSH Job pattern are less common (validated against official docs but fewer real-world examples)
- Pitfalls: HIGH - Sortable tags requirement, insecure registry config, read-write key requirement all confirmed in official docs
- Rollback: MEDIUM - Flux's lack of auto-rollback confirmed by maintainers, but the workaround (webhook + git revert) has limited documentation
- Sealed Secrets ARM64: MEDIUM - CLI confirmed ARM64, controller image needs runtime verification

**Research date:** 2026-02-07
**Valid until:** 2026-03-07 (30 days - Flux v2.7.x is stable, no major version expected soon)
